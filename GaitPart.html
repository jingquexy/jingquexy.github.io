<!DOCTYPE html><html><head>
<title>GaitPart.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*

Arduino® Light Theme - Stefania Mellai <s.mellai@arduino.cc>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #FFFFFF;
}

.hljs,
.hljs-subst {
  color: #434f54;
}

.hljs-keyword,
.hljs-attribute,
.hljs-selector-tag,
.hljs-doctag,
.hljs-name {
  color: #00979D;
}

.hljs-built_in,
.hljs-literal,
.hljs-bullet,
.hljs-code,
.hljs-addition {
  color: #D35400;
}

.hljs-regexp,
.hljs-symbol,
.hljs-variable,
.hljs-template-variable,
.hljs-link,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #00979D;
}

.hljs-type,
.hljs-string,
.hljs-selector-id,
.hljs-selector-class,
.hljs-quote,
.hljs-template-tag,
.hljs-deletion {
  color: #005C5F;
}

.hljs-title,
.hljs-section {
  color: #880000;
  font-weight: bold;
}

.hljs-comment {
  color: rgba(149,165,166,.8);
}

.hljs-meta-keyword {
  color: #728E00;
}

.hljs-meta {
  color: #434f54;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-function {
  color: #728E00;
}

.hljs-number {
  color: #8A7B52;  
}

</style>

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family:   "HelveticaNeue-Light", sans-serif, "宋体","Segoe WPC", "Segoe UI", "SFUIText-Light","Droid Sans Fallback";
	font-size: 18px;
	padding: 0 12px;
	line-height: 1.6;
	word-wrap: break-word;
	color: #333333;
}

.content-wrapper{
	max-width: 860px;
    margin: 0 auto;
    padding: 0 30px;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom: 1px solid #eee;
}


h2{
	padding-bottom: .3em;
    font-size: 2em;
    line-height: 1.225;
    border-bottom: 1px solid #eee;
}

h3{
	font-size: 1.75em;
    line-height: 1.225;
}

h1, h2, h3 {
	font-weight: bold;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

.table-of-contents li{
	list-style-type: initial;
}
</style>

<style>
@font-face{font-family:KaTeX_AMS;font-style:normal;font-weight:400;src:url(fonts/KaTeX_AMS-Regular.woff2) format("woff2"),url(fonts/KaTeX_AMS-Regular.woff) format("woff"),url(fonts/KaTeX_AMS-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Caligraphic-Bold.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Bold.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Caligraphic-Regular.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Regular.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Fraktur-Bold.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Bold.woff) format("woff"),url(fonts/KaTeX_Fraktur-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Fraktur-Regular.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Regular.woff) format("woff"),url(fonts/KaTeX_Fraktur-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Main-Bold.woff2) format("woff2"),url(fonts/KaTeX_Main-Bold.woff) format("woff"),url(fonts/KaTeX_Main-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Main-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Main-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Main-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Main-Italic.woff2) format("woff2"),url(fonts/KaTeX_Main-Italic.woff) format("woff"),url(fonts/KaTeX_Main-Italic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Main-Regular.woff2) format("woff2"),url(fonts/KaTeX_Main-Regular.woff) format("woff"),url(fonts/KaTeX_Main-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Math-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Math-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Math-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Math-Italic.woff2) format("woff2"),url(fonts/KaTeX_Math-Italic.woff) format("woff"),url(fonts/KaTeX_Math-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:700;src:url(fonts/KaTeX_SansSerif-Bold.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Bold.woff) format("woff"),url(fonts/KaTeX_SansSerif-Bold.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:italic;font-weight:400;src:url(fonts/KaTeX_SansSerif-Italic.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Italic.woff) format("woff"),url(fonts/KaTeX_SansSerif-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:400;src:url(fonts/KaTeX_SansSerif-Regular.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Regular.woff) format("woff"),url(fonts/KaTeX_SansSerif-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Script;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Script-Regular.woff2) format("woff2"),url(fonts/KaTeX_Script-Regular.woff) format("woff"),url(fonts/KaTeX_Script-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size1;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size1-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size1-Regular.woff) format("woff"),url(fonts/KaTeX_Size1-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size2;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size2-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size2-Regular.woff) format("woff"),url(fonts/KaTeX_Size2-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size3;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size3-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size3-Regular.woff) format("woff"),url(fonts/KaTeX_Size3-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size4;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size4-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size4-Regular.woff) format("woff"),url(fonts/KaTeX_Size4-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Typewriter;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Typewriter-Regular.woff2) format("woff2"),url(fonts/KaTeX_Typewriter-Regular.woff) format("woff"),url(fonts/KaTeX_Typewriter-Regular.ttf) format("truetype")}.katex{text-rendering:auto;font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0}.katex *{-ms-high-contrast-adjust:none!important;border-color:currentColor}.katex .katex-version:after{content:"0.16.2"}.katex .katex-mathml{clip:rect(1px,1px,1px,1px);border:0;height:1px;overflow:hidden;padding:0;position:absolute;width:1px}.katex .katex-html>.newline{display:block}.katex .base{position:relative;white-space:nowrap;width:-webkit-min-content;width:-moz-min-content;width:min-content}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathnormal{font-family:KaTeX_Math;font-style:italic}.katex .mathit{font-family:KaTeX_Main;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-style:italic;font-weight:700}.katex .amsrm,.katex .mathbb,.katex .textbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak,.katex .textfrak{font-family:KaTeX_Fraktur}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr,.katex .textscr{font-family:KaTeX_Script}.katex .mathsf,.katex .textsf{font-family:KaTeX_SansSerif}.katex .mathboldsf,.katex .textboldsf{font-family:KaTeX_SansSerif;font-weight:700}.katex .mathitsf,.katex .textitsf{font-family:KaTeX_SansSerif;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{border-collapse:collapse;display:inline-table;table-layout:fixed}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;position:relative;vertical-align:bottom}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;font-size:1px;min-width:2px;vertical-align:bottom;width:2px}.katex .vbox{align-items:baseline;display:inline-flex;flex-direction:column}.katex .hbox{width:100%}.katex .hbox,.katex .thinbox{display:inline-flex;flex-direction:row}.katex .thinbox{max-width:0;width:0}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline,.katex .hline,.katex .mfrac .frac-line,.katex .overline .overline-line,.katex .rule,.katex .underline .underline-line{min-height:1px}.katex .mspace{display:inline-block}.katex .clap,.katex .llap,.katex .rlap{position:relative;width:0}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{border:0 solid;display:inline-block;position:relative}.katex .hline,.katex .overline .overline-line,.katex .underline .underline-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline{border-bottom-style:dashed;display:inline-block;width:100%}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{position:relative}.katex .accent .accent-body:not(.accent-full){width:0}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;min-width:1px}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;display:block;height:inherit;position:absolute;width:100%}.katex svg path{stroke:none}.katex img{border-style:none;max-height:none;max-width:none;min-height:0;min-width:0}.katex .stretchy{display:block;overflow:hidden;position:relative;width:100%}.katex .stretchy:after,.katex .stretchy:before{content:""}.katex .hide-tail{overflow:hidden;position:relative;width:100%}.katex .halfarrow-left{left:0;overflow:hidden;position:absolute;width:50.2%}.katex .halfarrow-right{overflow:hidden;position:absolute;right:0;width:50.2%}.katex .brace-left{left:0;overflow:hidden;position:absolute;width:25.1%}.katex .brace-center{left:25%;overflow:hidden;position:absolute;width:50%}.katex .brace-right{overflow:hidden;position:absolute;right:0;width:25.1%}.katex .x-arrow-pad{padding:0 .5em}.katex .cd-arrow-pad{padding:0 .55556em 0 .27778em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox,.katex .fcolorbox{border:.04em solid;box-sizing:border-box}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap{margin-left:-.2em;margin-right:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}.katex .angl{border-right:.049em solid;border-top:.049em solid;box-sizing:border-box;margin-right:.03889em}.katex .anglpad{padding:0 .03889em}.katex .eqn-num:before{content:"(" counter(katexEqnNo) ")";counter-increment:katexEqnNo}.katex .mml-eqn-num:before{content:"(" counter(mmlEqnNo) ")";counter-increment:mmlEqnNo}.katex .mtr-glue{width:50%}.katex .cd-vert-arrow{display:inline-block;position:relative}.katex .cd-label-left{display:inline-block;position:absolute;right:calc(50% + .3em);text-align:left}.katex .cd-label-right{display:inline-block;left:calc(50% + .3em);position:absolute;text-align:right}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:block;text-align:center;white-space:nowrap}.katex-display>.katex>.katex-html{display:block;position:relative}.katex-display>.katex>.katex-html>.tag{position:absolute;right:0}.katex-display.leqno>.katex>.katex-html>.tag{left:0;right:auto}.katex-display.fleqn>.katex{padding-left:2em;text-align:left}body{counter-reset:katexEqnNo mmlEqnNo}

</style>

</head>
<body>
    <div class="content-wrapper">
        <h1 id="gaitpart" tabindex="-1">GaitPart</h1>
<hr>
<h1 id="0-%E6%91%98%E8%A6%81" tabindex="-1">0 摘要</h1>
<h2 id="1.-%E8%83%8C%E6%99%AF%E4%B8%8E%E7%97%9B%E7%82%B9%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8F%90%E5%87%BA%E6%96%B0%E6%96%B9%E6%B3%95%EF%BC%9F" tabindex="-1">1. 背景与痛点：为什么要提出新方法？</h2>
<ul>
<li>
<p><strong>步态识别的潜力：</strong> 步态识别是一种通过行人的走路姿态进行身份识别的生物特征技术。它的优势在于可以在<strong>远距离</strong>（不需要像人脸识别那样靠近摄像头）进行识别，因此应用前景非常广阔。</p>
</li>
<li>
<p><strong>现有的问题（Whole-body vs. Parts）：</strong> 目前大多数主流方法是将<strong>整个人体</strong>看作一个整体单元来提取时空特征。</p>
<ul>
<li><strong>缺陷：</strong> 作者观察到，人体在行走时，<strong>不同部位（如头、躯干、腿）的视觉外观和运动模式差异巨大</strong>。例如，手臂是摆动的，躯干相对静止，腿部则交替跨步。如果把全身“一视同仁”地混在一起分析，会忽略这些局部细节的差异。</li>
</ul>
</li>
</ul>
<h2 id="2.-%E6%A0%B8%E5%BF%83%E7%90%86%E5%BF%B5%EF%BC%9A%E5%88%86%E5%9D%97%E5%BB%BA%E6%A8%A1-(part-based-modeling)" tabindex="-1">2. 核心理念：分块建模 (Part-based Modeling)</h2>
<p>作者的假设非常直观：<strong>人体的每个部分都需要拥有独立的时空表达。</strong></p>
<p>基于最新的研究成果（局部特征对识别有益），作者提出了GaitPart 模型。这个模型的核心思想是不再“囫囵吞枣”地看全身，而是将人体切分为若干个部分，对每个部分分别进行精细化的分析。</p>
<h2 id="3.-%E5%85%B3%E9%94%AE%E5%88%9B%E6%96%B0%E7%82%B9%EF%BC%9Agaitpart-%E5%BC%BA%E5%9C%A8%E5%93%AA%EF%BC%9F" tabindex="-1">3. 关键创新点：GaitPart 强在哪？</h2>
<p>GaitPart 通过两个主要的技术模块来提升性能，分别对应空间（Spatial）和时间（Temporal）两个维度：</p>
<h3 id="a.-%E7%A9%BA%E9%97%B4%E7%BB%B4%E5%BA%A6%EF%BC%9Afocal-convolution-layer-(%E7%84%A6%E7%82%B9%E5%8D%B7%E7%A7%AF%E5%B1%82)" tabindex="-1">A. 空间维度：Focal Convolution Layer (焦点卷积层)</h3>
<ul>
<li><strong>作用：</strong> 增强<strong>局部（Part-level）空间特征</strong>的细粒度学习。</li>
<li><strong>解释：</strong> 普通的卷积可能关注全局，容易把特征“平滑”掉。焦点卷积层专门针对划分好的身体部位，提取更精细、更有针对性的外观特征。</li>
</ul>
<h3 id="b.-%E6%97%B6%E9%97%B4%E7%BB%B4%E5%BA%A6%EF%BC%9Amicro-motion-capture-module-(mcm%2C-%E5%BE%AE%E5%8A%A8%E6%8D%95%E6%8D%89%E6%A8%A1%E5%9D%97)" tabindex="-1">B. 时间维度：Micro-motion Capture Module (MCM, 微动捕捉模块)</h3>
<ul>
<li>
<p><strong>作用：</strong> 这是一个并行的结构，分别对应人体的不同部位。</p>
</li>
<li>
<p><strong>核心逻辑（短时 vs. 长时）：</strong></p>
<ul>
<li>以往的方法往往关注<strong>长距离</strong>的时间特征（比如看这人走了几十步）。作者认为步态是周期性的（走一步和走十步模式是一样的），长距离特征会有大量冗余。</li>
<li>MCM 专注于<strong>短距离（Short-range）的时间特征</strong>，也就是捕捉行走过程中瞬间的、微小的动作变化（Micro-motion）。这种方式更高效，且更能抓取到最具辨识度的运动细节。</li>
</ul>
</li>
</ul>
<h2 id="%E6%80%BB%E7%BB%93-summary" tabindex="-1">总结 Summary</h2>
<p>简单来说，这段话讲述了作者如何通过“化整为零”的策略改进了步态识别。</p>
<blockquote>
<p>传统方法就像是看一个人走路的“大概轮廓”和“长视频”；</p>
<p>GaitPart 则是把人切分成不同部位（头、身、腿），用“放大镜”看局部的细节（Focal Conv），并专注于捕捉瞬间的微小动作（MCM），从而实现了更精准的身份识别。</p>
</blockquote>
<hr>
<h1 id="1-introduction" tabindex="-1">1 Introduction</h1>
<h2 id="1.%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%AD%A5%E6%80%81%E8%AF%86%E5%88%AB%E7%8E%B0%E6%9C%89%E6%96%B9%E6%B3%95" tabindex="-1"><strong>1.基于深度学习的步态识别现有方法</strong></h2>
<p>文献回顾（Related Work）。主要介绍了三种代表性的深度学习思路，分别列举了基于<strong>3D-CNN</strong>、混合模型（Auto-Encoder + LSTM）<strong>和</strong>集合（Set）的三种不同技术路线：</p>
<h3 id="a.-%E5%9F%BA%E4%BA%8E-3d-cnn-%E7%9A%84%E6%96%B9%E6%B3%95-(thomas-et-al.)" tabindex="-1">A. 基于 3D-CNN 的方法 (Thomas et al.)</h3>
<ul>
<li>
<p><strong>核心技术：</strong> <strong>3D-CNN（三维卷积神经网络）</strong>。</p>
</li>
<li>
<p>“Thomas et al.[25] applied 3D-CNN to extract the spatio-temporal information, trying to find a general descriptor for human gait.” (<a href="zotero://select/library/items/2AKFTYPU">Fan 等, 2020, p. 14225</a>) (<a href="zotero://open-pdf/library/items/5WHYGL7L?page=1">pdf</a>)</p>
</li>
<li>
<p><strong>解释：</strong> 普通的卷积（2D-CNN）只能处理单张图片的<strong>空间</strong>信息（长和宽）。</p>
<ul>
<li>3D-CNN 则引入了<strong>时间</strong>维度，像切面包块一样同时处理视频的“长、宽、时间”。</li>
<li><strong>目的：</strong> 直接从视频块中提取<strong>时空联合特征</strong>（Spatio-temporal），试图找到一个通用的描述符来代表一个人的步态。</li>
</ul>
</li>
</ul>
<h3 id="b.-%E5%9F%BA%E4%BA%8E%E5%BA%8F%E5%88%97%E5%BB%BA%E6%A8%A1%E7%9A%84%E6%96%B9%E6%B3%95-(gaitnet)" tabindex="-1">B. 基于序列建模的方法 (GaitNet)</h3>
<ul>
<li>
<p><strong>核心技术：</strong> <strong>Auto-Encoder（自编码器） + LSTM（长短期记忆网络）</strong>。</p>
</li>
<li>
<p>“GaitNet[30] proposed an Auto-Encoder framework to extract the gait-related features from raw RGB images and then used LSTMs to model the temporal changes of gait sequence.” (<a href="zotero://select/library/items/2AKFTYPU">Fan 等, 2020, p. 14225</a>) (<a href="zotero://open-pdf/library/items/5WHYGL7L?page=1">pdf</a>)</p>
</li>
<li>
<p><strong>解释：</strong> 这是一个“分两步走”的策略：</p>
<ol>
<li><strong>空间提取：</strong> 使用自编码器从原始的 <strong>RGB 图像</strong>（注意：这里用的是彩色图，而非剪影）中提取与步态相关的视觉特征。</li>
<li><strong>时间建模：</strong> 将提取出的特征按时间顺序输入到 <strong>LSTM</strong> 中。LSTM 是一种专门处理序列数据的网络，它能“记住”动作的前后变化逻辑。</li>
</ol>
</li>
</ul>
<h3 id="c.-%E5%9F%BA%E4%BA%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95-(gaitset)" tabindex="-1">C. 基于集合的方法 (GaitSet)</h3>
<ul>
<li>
<p><strong>核心技术：</strong> <strong>Set-based Learning（基于集合的学习）</strong>。</p>
</li>
<li>
<p>“GaitSet[5] assumed that the appearance of a silhouette has contained its position information and thus regarded gait as a set to extract temporal information.” (<a href="zotero://select/library/items/2AKFTYPU">Fan 等, 2020, p. 14225</a>) (<a href="zotero://open-pdf/library/items/5WHYGL7L?page=1">pdf</a>)</p>
</li>
<li>
<p><strong>地位：</strong> GaitSet 是步态识别领域非常经典且极具颠覆性的论文。</p>
</li>
<li>
<p><strong>核心逻辑：</strong></p>
<ul>
<li><strong>传统思维：</strong> 认为走路是一个严格的序列（第一步 -&gt; 第二步 -&gt; 第三步），时间顺序很重要。</li>
<li><strong>GaitSet 的思维：</strong> 作者认为，单张剪影（Silhouette）的外观其实已经隐含了它的位置和状态信息。因此，<strong>不需要严格的时间顺序</strong>。</li>
<li>它把一个视频看作<strong>一堆图片的集合（Set）</strong>，而不是一个序列。这样做的好处是计算更灵活，对帧数和顺序不敏感。</li>
</ul>
</li>
</ul>
<h2 id="2.-%E5%8A%A8%E6%9C%BA%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8E%A8%E7%BF%BB%E6%97%A7%E6%96%B9%E6%B3%95%EF%BC%9F(motivation)" tabindex="-1">2. 动机：为什么要推翻旧方法？(Motivation)</h2>
<p>作者通过观察（Observation）和引用证据，指出了现有方法的两个主要缺陷，确立了 GaitPart 的设计哲学：</p>
<h3 id="a.-%E7%A9%BA%E9%97%B4%E4%B8%8A%EF%BC%9A%E4%BB%8E%E2%80%9C%E6%95%B4%E4%BD%93%E2%80%9D%E5%88%B0%E2%80%9C%E5%B1%80%E9%83%A8%E2%80%9D-(spatial)" tabindex="-1">A. 空间上：从“整体”到“局部” (Spatial)</h3>
<ul>
<li><strong>旧方法缺陷：</strong> 把整个人体当作一个单位处理。</li>
<li><strong>作者洞察：</strong> 人体不同部位（头、躯干、腿）在行走时的形状和运动模式完全不同（如图 1(a) 所示）。</li>
</ul>
<p>[image]</p>
<ul>
<li><strong>结论：</strong> “分而治之”是更好的策略。每个部位都需要独立的表达方式，因为局部的细粒度特征对识别身份更有帮助。</li>
</ul>
<h3 id="b.-%E6%97%B6%E9%97%B4%E4%B8%8A%EF%BC%9A%E4%BB%8E%E2%80%9C%E9%95%BF%E6%97%B6%E4%BE%9D%E8%B5%96%E2%80%9D%E5%88%B0%E2%80%9C%E5%BE%AE%E5%8A%A8%E6%A8%A1%E5%BC%8F%E2%80%9D-(temporal)" tabindex="-1">B. 时间上：从“长时依赖”到“微动模式” (Temporal)</h3>
<ul>
<li>
<p><strong>旧方法缺陷：</strong></p>
<ol>
<li>要么<strong>完全不建模时间</strong>（丢失了动作信息）。</li>
<li>要么<strong>过度建模长距离依赖</strong>（Long-range dependencies），比如使用深层 3D-CNN 或 RNN 去分析整个长视频序列。</li>
</ol>
</li>
<li>
<p><strong>作者洞察：</strong> 步态是<strong>周期性</strong>的（左脚迈完右脚迈，周而复始）。过长的序列包含大量重复冗余的信息，反而降低了识别的灵活性。</p>
</li>
<li>
<p><strong>结论：</strong> <strong>“短小精悍”是核心。局部的、短距离的时空特征（即微动模式 Micro-motion Patterns</strong>）才是最具辨识度的特征。</p>
</li>
</ul>
<h2 id="3.-%E6%9E%B6%E6%9E%84%EF%BC%9Agaitpart-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F(framework)" tabindex="-1">3. 架构：GaitPart 是如何工作的？(Framework)</h2>
<p>基于上述假设，作者提出了 GaitPart 框架（对应图 1(b)）。其处理流程如下：</p>
<p>[image]</p>
<pre class="hljs"><code><div>图 1：(a)：人类步态的不同部分在行走过程中具有明显不同的形状和运动模式。(b)：步态部分概述，由帧级部分特征提取器（FPFE）和微运动捕捉模块（MCM）组成。
</div></code></pre>
<ol>
<li>
<p><strong>输入：</strong> 一系列的步态剪影（Gait Silhouettes）。</p>
</li>
<li>
<p><strong>第一步：FPFE (帧级局部特征提取器)</strong></p>
<ul>
<li>这是一个特殊的堆叠 CNN。</li>
<li>它先处理每一帧图像，然后进行<strong>预定义的水平切割（Horizontal Partition）</strong>。</li>
<li><em>形象理解：</em> 就像把每一帧画面切成几条，分别对应头、肩、腰、腿等。</li>
</ul>
</li>
<li>
<p><strong>第二步：并行处理</strong></p>
<ul>
<li>切分后的每一部分（Part）都有自己独立的通道。</li>
<li>这些通道是<strong>相互独立</strong>的（Part-independent），互不干扰。</li>
</ul>
</li>
<li>
<p><strong>第三步：MCM (微动捕捉模块)</strong></p>
<ul>
<li>每个部位对应的序列进入各自的 MCM。</li>
<li>MCM 负责捕捉该部位特有的“微动模式”。</li>
</ul>
</li>
<li>
<p><strong>输出：</strong> 最后简单地将所有 MCM 的输出拼接（Concatenate）起来，形成最终的步态特征表达。</p>
</li>
</ol>
<h2 id="4.-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E8%B4%A1%E7%8C%AE-(contributions)" tabindex="-1">4. 三大核心贡献 (Contributions)</h2>
<p>作者总结了这篇论文的三个具体的创新点：</p>
<h3 id="%E5%88%9B%E6%96%B0%E7%82%B9-1%EF%BC%9Afocal-convolution-(fconv%2C-%E7%84%A6%E7%82%B9%E5%8D%B7%E7%A7%AF)-%E2%80%94%E2%80%94-%E9%92%88%E5%AF%B9%E7%A9%BA%E9%97%B4" tabindex="-1">创新点 1：Focal Convolution (FConv, 焦点卷积) —— 针对空间</h3>
<ul>
<li><strong>位置：</strong> 在 FPFE 模块中应用。</li>
<li><strong>核心思想：</strong> 这是一种简单但有效的卷积应用方式。它让卷积核（Kernel）专注于输入帧中<strong>特定部位的局部细节</strong>。</li>
<li><strong>目的：</strong> 增强对局部空间特征的“细粒度学习”（Fine-grained learning）。不仅仅是看个大概，而是要看清局部的纹理和形状。</li>
</ul>
<h3 id="%E5%88%9B%E6%96%B0%E7%82%B9-2%EF%BC%9Amicro-motion-capture-module-(mcm)-%E2%80%94%E2%80%94-%E9%92%88%E5%AF%B9%E6%97%B6%E9%97%B4" tabindex="-1">创新点 2：Micro-motion Capture Module (MCM) —— 针对时间</h3>
<ul>
<li><strong>理论依据：</strong> 作者认为，对于周期性步态，<strong>短距离</strong>的时空特征（微动）是最具辨识度的，而长距离依赖是冗余且低效的。</li>
<li><strong>技术实现：</strong> 提出了一个基于注意力机制（Attention-based）的 MCM。它既能捕捉局部的微小动作，也能兼顾对整个步态序列的全局理解。</li>
</ul>
<h3 id="%E5%88%9B%E6%96%B0%E7%82%B9-3%EF%BC%9Asota-%E6%95%88%E6%9E%9C%E9%AA%8C%E8%AF%81" tabindex="-1">创新点 3：SOTA 效果验证</h3>
<ul>
<li><strong>实验：</strong> 在两个最大的步态数据集（<strong>CASIA-B</strong> 和 <strong>OU-MVLP</strong>）上进行了广泛测试。</li>
<li><strong>结果：</strong> GaitPart 的性能大幅超越了之前的最先进方法（outperforms by a large margin）。同时，通过消融实验（Ablation experiments）证明了上述 FPFE 和 MCM 组件各自的有效性。</li>
</ul>
<h2 id="%E6%80%BB%E7%BB%93-(key-takeaway)" tabindex="-1">总结 (Key Takeaway)</h2>
<p>这段话的核心逻辑链条是：</p>
<blockquote>
<p>既然人体各部位运动不同 -&gt; 我们要分块处理 (Part-based)；</p>
<p>既然步态是周期性的 -&gt; 我们不需要看太长，只需看短时的微动 (Short-range/Micro-motion)。</p>
</blockquote>
<hr>
<h1 id="2-related-work" tabindex="-1">2 <strong>Related Work</strong></h1>
<p>为了方便理解，将这段内容拆解为 <strong>空间特征提取 (Spatial)</strong> 和 <strong>时间建模 (Temporal)</strong> 两个主要维度，以及作者针对这两点提出的<strong>针对性改进</strong>。</p>
<h2 id="1.-%E7%A9%BA%E9%97%B4%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96-(spatial-feature-extraction)" tabindex="-1">1. 空间特征提取 (Spatial Feature Extraction)</h2>
<p>作者主要讨论了如何处理单帧图像的空间特征，并对比了步态识别与行人重识别（Re-ID）的差异。</p>
<h3 id="a.-%E7%8E%B0%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E5%B1%80%E9%99%90" tabindex="-1">A. 现有方法的局限</h3>
<ul>
<li><strong>“一刀切”的问题：</strong> 以前的大多数方法（无论是基于 2D-CNN 还是 3D-CNN）都是对 <strong>整个特征图 (Whole Feature Map)</strong> 进行统一的卷积操作。</li>
<li><strong>作者的批判：</strong> 这种做法忽略了一个显而易见的事实——人体的不同部位（头、躯干、腿）在行走任务中具有显著的差异。把它们混在一起处理是不够精细的。</li>
</ul>
<blockquote>
<p><em>注：传统的 GEI 方法，它将所有动作压缩成一张图，模糊了具体的部位运动细节。</em></p>
</blockquote>
<h3 id="b.-%E5%80%9F%E9%89%B4%E4%B8%8E%E5%8C%BA%E5%88%86%EF%BC%9Apart-based-model-(%E5%9F%BA%E4%BA%8E%E5%88%86%E5%9D%97%E7%9A%84%E6%A8%A1%E5%9E%8B)" tabindex="-1">B. 借鉴与区分：Part-based Model (基于分块的模型)</h3>
<p>作者提到了在 <strong>Person Re-ID (行人重识别)</strong> 领域常用的“水平切片”方法，并指出了它与步态识别的区别</p>
<table><tbody><tr><td style="background-color: rgb(239, 239, 239);"><p><strong><span style="background-color: rgb(239, 239, 239)">领域</span></strong></p></td><td style="background-color: rgb(239, 239, 239);"><p><strong><span style="background-color: rgb(239, 239, 239)">假设前提 (Assumption)</span></strong></p></td><td style="background-color: rgb(239, 239, 239);"><p><strong><span style="background-color: rgb(239, 239, 239)">处理方式</span></strong></p></td></tr><tr><td style="background-color: rgba(0, 0, 0, 0);"><p><strong><span style="background-color: rgba(0, 0, 0, 0)">Person Re-ID</span></strong></p></td><td style="background-color: rgba(0, 0, 0, 0);"><p><span style="background-color: rgba(0, 0, 0, 0)">认为不同部位可能共享相同的属性（如衣服颜色、纹理），因此可以共享一部分参数。</span></p></td><td style="background-color: rgba(0, 0, 0, 0);"><p><span style="background-color: rgba(0, 0, 0, 0)">Part-shared (部分共享)</span></p></td></tr><tr><td style="background-color: rgba(0, 0, 0, 0);"><p><strong><span style="background-color: rgba(0, 0, 0, 0)">Gait Recognition</span></strong></p></td><td style="background-color: rgba(0, 0, 0, 0);"><p><span style="background-color: rgba(0, 0, 0, 0)">认为不同部位的</span><strong><span style="background-color: rgba(0, 0, 0, 0)">运动模式</span></strong><span style="background-color: rgba(0, 0, 0, 0)">和</span><strong><span style="background-color: rgba(0, 0, 0, 0)">外观形状</span></strong><span style="background-color: rgba(0, 0, 0, 0)">截然不同（头是不动的，腿是摆动的）。</span></p></td><td style="background-color: rgba(0, 0, 0, 0);"><p><strong><span style="background-color: rgba(0, 0, 0, 0)">Part-dependent (部分独立)</span></strong></p></td></tr></tbody></table>
<h3 id="c.-%E4%BD%9C%E8%80%85%E7%9A%84%E5%88%9B%E6%96%B0%EF%BC%9Afocal-convolution-(fconv)" tabindex="-1">C. 作者的创新：Focal Convolution (FConv)</h3>
<p>基于上述分析，作者提出了 <strong>FConv (焦点卷积)</strong>：</p>
<ul>
<li><strong>机制：</strong> 先将输入特征图切分成若干个水平条带（Parts），然后对<strong>每个条带单独进行卷积</strong>。</li>
<li><strong>目的：</strong> 当层数加深时，顶层神经元的<strong>感受野 (Receptive Field)</strong> 会被限制在该条带内部。</li>
<li><strong>效果：</strong> 强制网络专注于捕捉<strong>该部位内部的局部细节</strong>，而不是被其他部位的信息干扰。</li>
</ul>
<hr>
<h2 id="2.-%E6%97%B6%E9%97%B4%E5%BB%BA%E6%A8%A1-(temporal-modeling)" tabindex="-1">2. 时间建模 (Temporal Modeling)</h2>
<p>这一部分讨论如何处理视频序列中的时间信息。作者将现有方法分为三类，并指出了它们的不足，最后引出了自己的“短时建模”理念。</p>
<h3 id="a.-%E4%B8%89%E5%A4%A7%E7%8E%B0%E6%9C%89%E6%B5%81%E6%B4%BE%E5%AF%B9%E6%AF%94" tabindex="-1">A. 三大现有流派对比</h3>
<table><tbody><tr><td style="background-color: rgb(239, 239, 239);"><p><strong><span style="background-color: rgb(239, 239, 239)">流派</span></strong></p></td><td style="background-color: rgb(239, 239, 239);"><p><strong><span style="background-color: rgb(239, 239, 239)">代表方法</span></strong></p></td><td style="background-color: rgb(239, 239, 239);"><p><strong><span style="background-color: rgb(239, 239, 239)">优点</span></strong></p></td><td style="background-color: rgb(239, 239, 239);"><p><strong><span style="background-color: rgb(239, 239, 239)">缺点 (作者观点)</span></strong></p></td></tr><tr><td style="background-color: rgba(0, 0, 0, 0);"><p><strong><span style="background-color: rgba(0, 0, 0, 0)">3D-CNN</span></strong></p></td><td style="background-color: rgba(0, 0, 0, 0);"><p><span style="background-color: rgba(0, 0, 0, 0)">[25] 等</span></p></td><td style="background-color: rgba(0, 0, 0, 0);"><p><span style="background-color: rgba(0, 0, 0, 0)">直接提取时空特征。</span></p></td><td style="background-color: rgba(0, 0, 0, 0);"><p><span style="background-color: rgba(0, 0, 0, 0)">难以训练，性能提升有限。</span></p></td></tr><tr><td style="background-color: rgba(0, 0, 0, 0);"><p><strong><span style="background-color: rgba(0, 0, 0, 0)">LSTM (RNN)</span></strong></p></td><td style="background-color: rgba(0, 0, 0, 0);"><p><span style="background-color: rgba(0, 0, 0, 0)">GaitNet [30]</span></p></td><td style="background-color: rgba(0, 0, 0, 0);"><p><span style="background-color: rgba(0, 0, 0, 0)">能模拟时间序列变化。</span></p></td><td style="background-color: rgba(0, 0, 0, 0);"><p><strong><span style="background-color: rgba(0, 0, 0, 0)">“画蛇添足”</span></strong><span style="background-color: rgba(0, 0, 0, 0)">：步态是周期性的，不需要像语言那样严格的长序列约束。</span></p></td></tr><tr><td style="background-color: rgba(0, 0, 0, 0);"><p><strong><span style="background-color: rgba(0, 0, 0, 0)">Set-based (集合)</span></strong></p></td><td style="background-color: rgba(0, 0, 0, 0);"><p><span style="background-color: rgba(0, 0, 0, 0)">GaitSet [5]</span></p></td><td style="background-color: rgba(0, 0, 0, 0);"><p><span style="background-color: rgba(0, 0, 0, 0)">将视频看作图片集合，通过池化聚合特征。</span></p></td><td style="background-color: rgba(0, 0, 0, 0);"><p><strong><span style="background-color: rgba(0, 0, 0, 0)">简洁但粗糙</span></strong><span style="background-color: rgba(0, 0, 0, 0)">：虽然效果好，但没有显式地去建模时间的动态变化 (Micro-motion)。</span></p></td></tr></tbody></table>
<h3 id="b.-%E4%BD%9C%E8%80%85%E7%9A%84%E6%B4%9E%E5%AF%9F%EF%BC%9A%E9%95%BF%E6%97%B6%E4%BE%9D%E8%B5%96-vs.-%E7%9F%AD%E6%97%B6%E5%BE%AE%E5%8A%A8" tabindex="-1">B. 作者的洞察：长时依赖 vs. 短时微动</h3>
<ul>
<li>
<p><strong>观察：</strong> 步态是<strong>周期性 (Periodic)</strong> 的。走完一个周期（左脚迈出到右脚跟上），动作就会重复。</p>
</li>
<li>
<p><strong>推论：</strong></p>
<ul>
<li><strong>长距离依赖 (Long-range dependencies)</strong> 是冗余的。看一个人走 100 步和走 2 步，获取的身份信息其实差不多，反而增加了计算负担。</li>
<li><strong>短距离特征 (Local short-range)</strong> 才是关键。即在一个周期内的微小动作变化（Micro-motion）。</li>
</ul>
</li>
</ul>
<h3 id="c.-%E4%BD%9C%E8%80%85%E7%9A%84%E5%88%9B%E6%96%B0%EF%BC%9Amicro-motion-capture-module-(mcm)" tabindex="-1">C. 作者的创新：Micro-motion Capture Module (MCM)</h3>
<p>基于此，作者提出了 <strong>MCM (微动捕捉模块)</strong>。</p>
<ul>
<li><strong>核心策略：</strong> 放弃捕捉冗长的全局序列关系，转而专注于<strong>局部的、短时的微动特征</strong>建模。这将在Sec 3.3详细讨论。</li>
</ul>
<h2 id="summary" tabindex="-1">Summary</h2>
<p>这段 Related Work 的核心逻辑链条如下：</p>
<ol>
<li><strong>空间上：</strong> 既然人体各部位运动不同 -&gt; <strong>我们要分块 (Part-based)</strong> -&gt; 但不能像 Re-ID 那样共享参数，要独立处理 -&gt; 提出 <strong>FConv</strong>。</li>
<li><strong>时间上：</strong> 既然步态是周期性的 -&gt; 长时间序列是啰嗦的 -&gt; <strong>我们要关注短时微动</strong> -&gt; 提出 <strong>MCM</strong>。</li>
</ol>
<hr>
<h1 id="3.1-pipeline" tabindex="-1">3.1 Pipeline</h1>
<p>[image]</p>
<pre class="hljs"><code><div>图2：GaitPart的框架。Block1、2和3由FConvs和池化层组成。HP为水平池化，MCM为微运动捕捉模块。其中，MCM_j是组成局部特征矩阵中第j行的所有向量，生成时空特征v_j，以便最终识别。
</div></code></pre>
<h2 id="1.-%E5%9B%BE%E5%83%8F%E8%BE%93%E5%85%A5%E4%B8%8E%E7%A9%BA%E9%97%B4%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96-(input-%26-fpfe)" tabindex="-1">1. 图像输入与空间特征提取 (Input &amp; FPFE)</h2>
<ul>
<li><strong>输入：</strong> 模型接收一个包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>帧的步态剪影序列（Sequence of gait silhouettes）作为输入。</li>
<li><strong>处理模块：</strong> <strong>帧级局部特征提取器 (FPFE)</strong>。这是一个专门设计的卷积网络（如图中 Block1, Block2, Block3 所示），它逐帧处理输入图像。</li>
<li><strong>输出：</strong> 对于序列中的每一帧 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，FPFE 会生成对应的空间特征图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">F_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。这产生了一个特征图序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>F</mi></msub></mrow><annotation encoding="application/x-tex">S_F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</li>
</ul>
<h2 id="2.-%E6%B0%B4%E5%B9%B3%E6%B1%A0%E5%8C%96%E4%B8%8E%E5%88%87%E5%88%86-(horizontal-pooling---hp)" tabindex="-1">2. 水平池化与切分 (Horizontal Pooling - HP)</h2>
<p>为了获得人体局部的精细特征，模型对特征图进行了特殊的处理：</p>
<ul>
<li>
<p><strong>水平切分：</strong> <strong>HP 模块</strong>将每个特征图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">F_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在水平方向上切分为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个部分（parts）。</p>
</li>
<li>
<p><strong>池化操作：</strong> 对于每一个切分出来的部分（第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>部分），HP 模块结合使用了<strong>全局平均池化 (Global Average Pooling)</strong> 和 <strong>全局最大池化 (Global Max Pooling)</strong>。</p>
<ul>
<li>公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo>=</mo><mtext>Avgpool2d</mtext><mo stretchy="false">(</mo><msub><mi>F</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><mtext>Maxpool2d</mtext><mo stretchy="false">(</mo><msub><mi>F</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_{j,i} = \text{Avgpool2d}(F_{j,i}) + \text{Maxpool2d}(F_{j,i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord text"><span class="mord">Avgpool2d</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord text"><span class="mord">Maxpool2d</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。</li>
</ul>
</li>
<li>
<p><strong>结果：</strong> 这一步将三维的特征图降维成了特征列向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{j,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 。</p>
</li>
</ul>
<h2 id="3.-%E6%9E%84%E5%BB%BA-(part-representation-matrix)" tabindex="-1">3. 构建 (Part Representation Matrix)</h2>
<ul>
<li>
<p>经过 HP 处理后，整个步态序列被转化为一个 <strong>局部特征矩阵 (PR-Matrix)</strong>，记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 。</p>
</li>
<li>
<p><strong>结构含义：</strong> 这是一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">n \times t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>的 矩阵（如图 2 中间部分的网格所示）：</p>
<ul>
<li><strong>列 (Column)：</strong> 代表某一时刻（第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>帧 ）全身各部位的特征。</li>
<li><strong>行 (Row)：</strong> 代表人体<strong>某一部位（第</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span><strong>部 分）随时间变化</strong>的特征序列，记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>j</mi><mo separator="true">,</mo><mo>⋅</mo></mrow></msub></mrow><annotation encoding="application/x-tex">P_{j,\cdot}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">⋅</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 。这一行向量直观地反映了该特定身体部位的步态变化。</li>
</ul>
</li>
</ul>
<h2 id="4.-%E6%97%B6%E5%BA%8F%E7%89%B9%E5%BE%81%E8%81%9A%E5%90%88-(temporal-feature-aggregator---tfa)" tabindex="-1">4. 时序特征聚合 (Temporal Feature Aggregator - TFA)</h2>
<p>最后一步是对时间维度进行建模，提取最终的识别特征：</p>
<ul>
<li>
<p><strong>并行处理：</strong> 既然每一行代表一个身体部位，GaitPart使用了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个并行的<strong>微动捕捉模块 (MCM)</strong> 来分别处理这些行向量。</p>
<ul>
<li>例如，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>C</mi><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">MCM_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">MC</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>专门处理头部序列，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>C</mi><msub><mi>M</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">MCM_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">MC</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>专门处理腿部序列。</li>
</ul>
</li>
<li>
<p><strong>独立性：</strong> 值得注意的是，这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个 MCM 的参数是<strong>相互独立</strong>的。这意味着模型是“部位独立”（Part-dependent）的，每个部位都有自己专属的参数来捕捉其独特的微动模式。</p>
</li>
<li>
<p><strong>输出：</strong> 每个 MCM 输出一个特征向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 。最后，这些向量通过独立的全连接层（FC）映射到度量空间，用于计算 Triplet Loss 进行身份识别。</p>
</li>
</ul>
<h2 id="%E6%80%BB%E7%BB%93" tabindex="-1">总结</h2>
<p>简单来说，这个 Pipeline 的核心逻辑是：<strong>先逐帧提取图像特征，然后把人切成</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span><strong>条 ，最后让</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span><strong>个独立的处理器分别去分析这</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span><strong>个条带随时间的细微变化。</strong></p>
<hr>
<h1 id="3.2-%E5%B8%A7%E7%BA%A7%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%99%A8fpfe" tabindex="-1">3.2 <strong>帧级局部特征提取器</strong>FPFE</h1>
<p>[image]</p>
<pre class="hljs"><code><div>图3.(a)：深层网络中顶层神经元感受野的扩展。上：常规情况。底部：使用FConv。 (b)：FConv的示意图，特征图按其尺寸显示，例如C×H×W。
</div></code></pre>
<p><strong>FPFE (帧级局部特征提取器)</strong> 及其核心组件 <strong>FConv (焦点卷积)</strong>。这是 GaitPart 模型中负责提取空间特征的关键部分。</p>
<h2 id="1.-%E6%A0%B8%E5%BF%83%E5%88%9B%E6%96%B0%EF%BC%9Afocal-convolution-(fconv%2C-%E7%84%A6%E7%82%B9%E5%8D%B7%E7%A7%AF)" tabindex="-1">1. 核心创新：Focal Convolution (FConv, 焦点卷积)</h2>
<p>作者提出 FConv 是为了解决传统卷积“看太宽”的问题。</p>
<h3 id="a.-%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6-(operation)" tabindex="-1"><strong>A. 运作机制 (Operation)</strong></h3>
<p>可以把 FConv 想象成一个“分而治之”的处理过程。</p>
<p>[image]</p>
<ol>
<li><strong>切分 (Split)：<strong>输入的特征图被</strong>水平切分</strong>成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>个 部分（Strips）。例如图中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">p=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> ，图像就被切成了 4 个横条。</li>
<li>**独立卷积 (Separate Convolution)：**对每一个切分出来的横条，<strong>分别</strong>进行常规的卷积操作。</li>
<li>**拼接 (Concatenate)：**处理完后，再把这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>个结果在水平方向上重新拼回去，形成输出特征图。</li>
</ol>
<blockquote>
<p><strong>注意：</strong> 当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>时 ，FConv 就等同于普通的卷积层。</p>
</blockquote>
<h3 id="b.-%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA-(motivation)" tabindex="-1"><strong>B. 设计动机 (Motivation)</strong></h3>
<p>为什么要这么麻烦地切开再卷？核心目的是为了<strong>限制感受野 (Receptive Field)</strong>：</p>
<p>[image]</p>
<ul>
<li>**传统卷积 (上方图示)：**随着网络层数加深，顶层神经元的感受野会变得很大，甚至覆盖全身。这意味着处理“腿部”特征的神经元可能会受到“头部”信息的干扰。</li>
<li><strong>FConv (下方图示)：<strong>通过切分，强制卷积核只在各自的横条内滑动。这样，即使网络很深，顶层神经元的关注点依然被</strong>限制</strong>在对应的局部区域内（Local details）。</li>
<li><strong>好处：</strong> 这能增强对<strong>细粒度特征 (Fine-grained features)</strong> 的学习，让腿部的特征提取器只专注于腿部细节，不受上半身干扰。</li>
</ul>
<h2 id="2.-%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%EF%BC%9Aframe-level-part-feature-extractor-(fpfe)" tabindex="-1">2. 整体结构：Frame-level Part Feature Extractor (FPFE)</h2>
<p>理解了 FConv 后，FPFE 的结构就很好理解了。它是一个专门设计的卷积网络，用于处理输入的每一帧剪影。</p>
<ul>
<li><strong>位置：</strong> 在整个 GaitPart 流程中，FPFE 位于最前端。它包含 Block1, Block2, Block3。</li>
</ul>
<p>[image]</p>
<ul>
<li><strong>组成：</strong> FPFE 由 <strong>3 个 Block</strong> 组成。</li>
<li><strong>内部构造：</strong> 每个 Block 内部包含 <strong>2 个 FConv 层</strong>。</li>
</ul>
<p>[image]</p>
<pre class="hljs"><code><div>表1. 帧级局部特征提取器的具体结构。InC、OutC、Kernel和Pad分别表示FConv的输入通道、输出通道、内核大小和填充。特别地，p表示FConv中预定义部分的数量。
</div></code></pre>
<h2 id="%E6%80%BB%E7%BB%93-1" tabindex="-1">总结</h2>
<p>FPFE 的设计哲学非常明确：通过堆叠 FConv，模型在提取空间特征时，人为地设立了“隔离带”。这确保了当信息从浅层传到深层时，头部、躯干和腿部的特征是相对独立演化的，从而提取出更纯净、更具辨识度的局部空间特征。</p>
<h1 id="3.3-%E6%97%B6%E5%BA%8F%E7%89%B9%E5%BE%81%E8%81%9A%E5%90%88%E5%99%A8tfa" tabindex="-1">3.3 <strong>时序特征聚合器TFA</strong></h1>
<p><strong>GaitPart</strong> 模型中的<strong>时序特征聚合器 (Temporal Feature Aggregator, TFA)</strong> 及其核心组件<strong>微动捕捉模块 (Micro-motion Capture Module, MCM)</strong>。</p>
<p>[image]</p>
<p>这是模型处理“时间”维度的关键部分。拆解为三个层级：<strong>总体架构</strong>、<strong>第一步：构建微动 (MTB)</strong> 和 <strong>第二步：时序池化 (TP)</strong></p>
<h2 id="1.-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%EF%BC%9Amcm-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F" tabindex="-1">1. 总体架构：MCM 是做什么的？</h2>
<p>[image]</p>
<pre class="hljs"><code><div>图4.微动捕捉模块（MCM，包括MTB和TP模块）的详细结构。 MTB模块在序列维度上滑动，将每个相邻的2r+1列向量压缩成微动特征向量。然后，TP模块使用一个简单最大值函数来收集帧和通道维度中最具辨别力的微运动特征以进行最终识别。
</div></code></pre>
<ul>
<li>
<p><strong>角色：</strong> 这一步发生在“切片”之后。既然人体被切成了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个水平条带，我们就有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个并行的通道。TFA 就是由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个并行的 <strong>MCM</strong> 组成的。</p>
</li>
<li>
<p><strong>任务：</strong> 每个 MCM 负责处理对应身体部位的特征序列（即 PR-Matrix 中的一行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">S_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> ）。</p>
</li>
<li>
<p><strong>流程：</strong> 一个 MCM 内部包含两个子模块，按顺序执行：</p>
<ol>
<li>**MTB (Micro-motion Template Builder)：**负责捕捉短时的微小动作。</li>
<li>**TP (Temporal Pooling)：**负责将整个序列聚合成一个最终特征向量。</li>
</ol>
</li>
</ul>
<p>[image]</p>
<pre class="hljs"><code><div>图5. 实际微动作捕捉模块MCM的抽象结构，包含TP和两个具有不同窗口大小（3和5）的并行MTB模块。
</div></code></pre>
<blockquote>
<p><em>注：如图 5 所示，实际应用中，一个 MCM 包含了两个并行的 MTB 分支（MTB1 和 MTB2）以及一个 TP 模块。</em></p>
</blockquote>
<h2 id="2.-%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%BE%AE%E5%8A%A8%E6%A8%A1%E6%9D%BF%E6%9E%84%E5%BB%BA%E5%99%A8-(mtb)" tabindex="-1">2. 第一步：微动模板构建器 (MTB)</h2>
<p>这是 MCM 的核心创新点。作者认为，步态识别不需要看太长，<strong>短时 (Short-range)</strong> 的邻域特征才是最关键的。</p>
<h3 id="a.-%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-(sliding-window)" tabindex="-1"><strong>A. 核心逻辑：滑动窗口 (Sliding Window)</strong></h3>
<p>MTB 就像一个滑动的窗口探测器。</p>
<ul>
<li>
<p><strong>输入：</strong> 某一时刻的特征 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 及其前后的邻居帧（共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>r</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2r+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>帧 ）。</p>
</li>
<li>
<p>**操作 (TempFunc):**在这个小窗口内，通过统计函数把这些帧“压缩”成一个微动特征向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</p>
</li>
<li>
<p><strong>具体算法：</strong> 作者借鉴了 GEI 的思路，使用了<strong>1D Global Average Pooling</strong> 和 <strong>1D Global Max Pooling</strong> 的相加。</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>=</mo><mtext>Avgpool1d</mtext><mo stretchy="false">(</mo><msub><mi>S</mi><mi>p</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mtext>Maxpool1d</mtext><mo stretchy="false">(</mo><msub><mi>S</mi><mi>p</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_m = \text{Avgpool1d}(S_p) + \text{Maxpool1d}(S_p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord text"><span class="mord">Avgpool1d</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord text"><span class="mord">Maxpool1d</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
</ul>
<h3 id="b.-%E5%A2%9E%E5%BC%BA%E6%9C%BA%E5%88%B6%EF%BC%9A%E9%80%9A%E9%81%93%E6%B3%A8%E6%84%8F%E5%8A%9B-(channel-wise-attention)" tabindex="-1"><strong>B. 增强机制：通道注意力 (Channel-wise Attention)</strong></h3>
<p>为了进一步提取更有辨识度的特征，MTB 引入了注意力机制来对特征进行“重加权” (Re-weighting)。</p>
<p>[image]</p>
<pre class="hljs"><code><div>表2. MTB1和MTB2的确切结构。InC、OutC、Kernel和Pad分别表示FConv的输入通道、输出通道、内核大小和填充。特别地，C和s分别表示输入特征图的通道和压缩比。请注意，“|”两边的值分别代表MTB1和MTB2的设置。
</div></code></pre>
<ul>
<li>使用一个小型的卷积网络 <strong>Conv1dNet</strong>（结构见 Table 2）来计算权重。</li>
<li><strong>公式：</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>S</mi><mi>m</mi><mrow><mi>r</mi><mi>e</mi></mrow></msubsup><mo>=</mo><msub><mi>S</mi><mi>m</mi></msub><mo>⋅</mo><mtext>Sigmoid</mtext><mo stretchy="false">(</mo><msub><mi>S</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>i</mi><mi>t</mi><mi>s</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_m^{re} = S_m \cdot \text{Sigmoid}(S_{logits})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9303em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">re</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord text"><span class="mord">Sigmoid</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。</li>
<li><strong>目的：</strong> 自动判断哪些通道的微动特征更重要，予以放大；哪些是噪声，予以抑制。</li>
</ul>
<h3 id="c.-%E5%A4%9A%E5%B0%BA%E5%BA%A6%E8%AE%BE%E8%AE%A1-(multi-scale)" tabindex="-1"><strong>C. 多尺度设计 (Multi-scale)</strong></h3>
<p>如图5和图 4 所示，作者在实践中使用了 <strong>两个并行的 MTB</strong>：</p>
<ul>
<li>**MTB1：**窗口大小为 3 (Kernel=3)。</li>
<li>**MTB2：**窗口大小为 5 (Kernel=5)。</li>
<li><strong>目的：</strong> 融合不同尺度的时序信息，捕捉不同速度或跨度的微动特征。</li>
</ul>
<h2 id="3.-%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E6%97%B6%E5%BA%8F%E6%B1%A0%E5%8C%96-(tp)" tabindex="-1">3. 第二步：时序池化 (TP)</h2>
<p>MTB 输出的是一串微动特征序列，TP 的任务是把这串序列变成<strong>一个</strong>向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> ，作为最终的身份指纹。</p>
<h3 id="a.-%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%88%99%EF%BC%9A%E6%AD%A5%E6%80%81%E6%97%B6%E5%BA%8F%E8%81%9A%E5%90%88%E5%8E%9F%E5%88%99" tabindex="-1"><strong>A. 核心原则：步态时序聚合原则</strong></h3>
<p>作者提出了一个非常重要的理论依据：<strong>Ground Principle of Gait Temporal Aggregation</strong>。</p>
<ul>
<li><strong>含义：</strong> 步态是<strong>周期性</strong>的。在一个完整的周期（Cycle）内，信息量已经饱和。</li>
<li><strong>推论：</strong> 只要视频长度超过一个周期，再增加视频长度，不应该改变提取出的特征结果。</li>
</ul>
<h3 id="b.-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-max-pooling%EF%BC%9F" tabindex="-1"><strong>B. 为什么选 Max Pooling？</strong></h3>
<p>作者对比了两种聚合方式：</p>
<ol>
<li>
<p><strong>Mean (平均值):</strong></p>
<ul>
<li><strong>缺点：</strong> 平均值会受到视频长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>的影响。如果视频长度不是周期的整数倍，平均值会波动。这对现实中长度不定的视频很不友好。</li>
</ul>
</li>
<li>
<p><strong>Max (最大值):</strong></p>
<ul>
<li><strong>优点：</strong> 只要视频包含至少一个完整周期，序列中的最大值（Max）就是固定的。</li>
<li><strong>结论：</strong> Max Pooling 完美符合上述原则（Eq.11 = Eq.12），因此被选为最终方案。</li>
</ul>
</li>
</ol>
<h2 id="summary-1" tabindex="-1">Summary</h2>
<p><strong>MCM 的工作流程</strong>可以概括为：</p>
<ol>
<li>用不同大小的<strong>滑动窗口</strong>（3 和 5）扫过整个视频序列。</li>
<li>在窗口内提取<strong>微动特征</strong>并利用<strong>注意力机制</strong>强化关键信息。</li>
<li>最后，用 <strong>Max Pooling</strong> 挑出整个过程中最显著的特征，以此作为该身体部位的最终步态表达。</li>
</ol>
<hr>
<h1 id="3.4-%E5%AE%9E%E6%96%BD%E7%BB%86%E8%8A%82-(implementation-details)" tabindex="-1">3.4 <strong>实施细节 (Implementation Details)</strong></h1>
<p>这部分内容不再涉及新的理论创新，而是侧重于“怎么把模型搭建出来”、“怎么训练”以及“怎么测试”。分为<strong>网络配置</strong>、<strong>训练策略</strong>和<strong>测试方法</strong> 三个部分。</p>
<h2 id="1.-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%B6%85%E5%8F%82%E6%95%B0-(network-hyper-parameters)" tabindex="-1">1. 网络配置与超参数 (Network Hyper-parameters)</h2>
<p>这部分主要补充了 FPFE（帧级特征提取器）的具体设置，特别是关于 FConv 中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 值（分块数量）的选择。</p>
<ul>
<li>
<p><strong>基础组件：</strong> FPFE 由 FConv 层、Max Pooling 层和 Leaky ReLU 激活函数组成。</p>
</li>
<li>
<p><strong>核心参数</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span><strong>( Parts Number)：</strong></p>
<p>[image]</p>
<ul>
<li><strong>设置规律：</strong> 随着网络层数变深，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 的值逐渐增大。</li>
<li><strong>具体配置：</strong> 参照 <strong>Table 1</strong>，Block 1 中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> （相当于普通卷积），Block 2 中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">p=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> ，Block 3 中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">p=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span> 。</li>
<li><strong>原因：</strong> 当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>越大，对感受野的限制就越强。在浅层（Deep shallow）我们允许感受野大一点，但在深层（Deep layers），为了提取精细的局部特征，强制限制感受野只关注局部。</li>
</ul>
</li>
</ul>
<h2 id="2.-%E8%AE%AD%E7%BB%83%E7%AD%96%E7%95%A5%EF%BC%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%87%87%E6%A0%B7-(loss-and-sampler)" tabindex="-1">2. 训练策略：损失函数与数据采样 (Loss and Sampler)</h2>
<p>这部分解决了两个实际问题：用什么标准来优化网络？以及长短不一的视频怎么喂给模型？</p>
<h3 id="a.-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0-loss-function" tabindex="-1"><strong>A. 损失函数 Loss Function</strong></h3>
<ul>
<li><strong>方法：</strong> 采用了 <strong>Separate Batch All (BA+) Triplet Loss</strong>（分离的难样本三元组损失）。</li>
<li><strong>分离 (Separate) 的含义：</strong> 模型输出了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个特征向量（分别对应头、身、腿等）。计算损失时，是<strong>对应的部位和对应的部位比</strong>（比如：用样本 A 的“头部”去对比样本 B 的“头部”），而不是混在一起比。</li>
<li>**Batch Size：**设定为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>p</mi><mi>r</mi></msub><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(p_r, k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">p_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是人数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>是每个人抽取的样本数。</li>
</ul>
<h3 id="b.-%E6%95%B0%E6%8D%AE%E9%87%87%E6%A0%B7-(sampler)" tabindex="-1"><strong>B. 数据采样 (Sampler)</strong></h3>
<p>步态视频长度不一，但训练神经网络通常需要固定的输入维度。作者采取了以下策略：</p>
<ul>
<li>
<p><strong>训练阶段 (Train Phase)：</strong> 必须凑齐固定的 <strong>30 帧</strong>。</p>
<ol>
<li><strong>正常视频：</strong> 先截取一段 30-40 帧的片段，然后从中随机抽取并排序 <strong>30 帧</strong>作为输入。</li>
<li><strong>过短视频 (&lt;15 帧)：</strong> 直接丢弃 (Discard)。</li>
<li><strong>中等视频 (15-30 帧)：</strong> 重复采样 (Repeatedly sampled) 直到凑够数。</li>
</ol>
</li>
<li>
<p><strong>测试阶段 (Test Phase)：</strong> 不需要固定长度，<strong>原始视频 (Raw video)</strong> 直接输入模型进行全量计算。</p>
</li>
</ul>
<h2 id="3.-%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95-(testing)" tabindex="-1">3. 测试方法 (Testing)</h2>
<ul>
<li><strong>距离度量：</strong> 在比对两个样本（Gallery vs. Probe）时，计算它们输出的特征向量之间的<strong>欧几里得距离 (Euclidean distance)</strong>。</li>
<li><strong>最终得分：</strong> 将所有部位（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个 向量）的距离取<strong>平均值 (Average)</strong>，作为判定两个人是否为同一人的最终依据。</li>
</ul>
<h2 id="%E6%80%BB%E7%BB%93-2" tabindex="-1">总结</h2>
<p>这一节不仅提供了复现代码所需的具体参数，还给出了处理非定长视频数据的实用工程技巧（采样策略）。</p>
<hr>
<h1 id="4-%E5%AE%9E%E9%AA%8C%E8%AE%BE%E7%BD%AE" tabindex="-1">4 实验设置</h1>
<h2 id="4.1-%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BB%8B%E7%BB%8D%E5%92%8C%E8%AE%AD%E7%BB%83%E9%85%8D%E7%BD%AE" tabindex="-1">4.1 <strong>数据集介绍</strong>和<strong>训练配置</strong></h2>
<h3 id="1.-%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BB%8B%E7%BB%8D-(datasets)" tabindex="-1">1. 数据集介绍 (Datasets)</h3>
<p>作者选择了两个最具代表性的公开步态数据集：<strong>CASIA-B</strong>（侧重多状态变化）和 <strong>OU-MVLP</strong>（侧重海量数据规模）。</p>
<h4 id="a.-casia-b-(%E5%A4%8D%E6%9D%82%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E9%9B%86)" tabindex="-1"><strong>A. CASIA-B (复杂状态数据集)</strong></h4>
<p>这是一个广泛使用的中等规模数据集，最大的特点是<strong>包含多种行走状态</strong>（如背包、穿大衣），非常考验模型的鲁棒性。</p>
<ul>
<li>
<p><strong>规模：</strong> 124 个对象（Subjects）。</p>
</li>
<li>
<p><strong>视角 (Views)：</strong> 每个人有 11 个视角（0° 到 180°，每 18° 一个视角）。</p>
</li>
<li>
<p><strong>行走状态 (Conditions)：</strong> 每个视角下有 10 个序列，分为三类：</p>
<ul>
<li>**NM (Normal, 正常行走)：**6 个序列 (NM#1-6)。</li>
<li>**BG (Bag, 背包)：**2 个序列 (BG#1-2)。</li>
<li>**CL (Clothing, 穿外套)：**2 个序列 (CL#1-2)。</li>
</ul>
</li>
<li>
<p>**实验协议 (Protocol)：**遵循标准协议：</p>
<ul>
<li>
<p><strong>训练集：</strong> 前 74 人。</p>
</li>
<li>
<p><strong>测试集：</strong> 后 50 人。</p>
</li>
<li>
<p><strong>测试方式：</strong></p>
<ul>
<li>**Gallery (注册库/底库)：**NM#1-4（即用这 4 次正常行走的视频作为已知底库）。</li>
<li>**Probe (探针/待测样本)：**分为三个子集进行测试——NM#5-6（测正常）、BG#1-2（测背包）、CL#1-2（测换衣）。</li>
</ul>
</li>
<li>
<p><em>注：CL（换衣）通常是最难识别的场景。</em></p>
</li>
</ul>
</li>
</ul>
<h4 id="b.-ou-mvlp-(%E8%B6%85%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E9%9B%86)" tabindex="-1"><strong>B. OU-MVLP (超大规模数据集)</strong></h4>
<p>这是目前世界上最大的公开步态数据集，主要考验模型在大数据下的泛化能力。</p>
<ul>
<li><strong>规模：</strong> 10,307 个对象（是 CASIA-B 的近百倍）。</li>
<li><strong>划分：</strong> 5,153 人用于训练，5,154 人用于测试。</li>
<li><strong>视角：</strong> 14 个视角（覆盖 0°-90° 和 180°-270°）。</li>
<li><strong>序列：</strong> 每个视角只有 2 个序列（#01, #02）。</li>
<li><strong>测试方式：</strong> 序列 #01 做底库 (Gallery)，序列 #02 做待测 (Probe)。</li>
</ul>
<h3 id="2.-%E8%AE%AD%E7%BB%83%E7%BB%86%E8%8A%82-(training-details)" tabindex="-1">2. 训练细节 (Training Details)</h3>
<p>为了保证实验公平且可复现，作者详细列出了参数设置。值得注意的是，针对两个不同规模的数据集，模型配置略有调整。</p>
<h4 id="a.-%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE-(common-configuration)" tabindex="-1"><strong>A. 通用配置 (Common Configuration)</strong></h4>
<ul>
<li><strong>输入尺寸：</strong> 所有的步态剪影被调整为 <strong>64 × 44</strong>。</li>
<li><strong>优化器：</strong> Adam。</li>
<li>**学习率 (LR)：**1e-4。</li>
<li>**三元组损失 Margin：**0.2。</li>
</ul>
<h4 id="b.-%E9%92%88%E5%AF%B9-casia-b-%E7%9A%84%E9%85%8D%E7%BD%AE" tabindex="-1"><strong>B. 针对 CASIA-B 的配置</strong></h4>
<ul>
<li><strong>Batch Size：</strong>(8, 16)。<em>一个 Batch 包含 8个人，每个人取 16 个样本。</em></li>
<li>**迭代次数：**12 万次 (120K)。</li>
</ul>
<h4 id="c.-%E9%92%88%E5%AF%B9-ou-mvlp-%E7%9A%84%E7%89%B9%E6%AE%8A%E8%B0%83%E6%95%B4" tabindex="-1"><strong>C. 针对 OU-MVLP 的特殊调整</strong></h4>
<p>由于这个数据集数据量巨大（是 CASIA-B 的 20 倍），作者加深了网络结构：</p>
<ul>
<li>
<p><strong>网络加深：</strong> 在 FPFE 中<strong>增加了一个额外的 Block</strong>（包含两个 FConv 层），输出通道数设为 256。</p>
</li>
<li>
<p><strong>参数</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span><strong>的 调整：</strong> 随着网络加深，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>值 （分块数）设置为 <strong>1, 1, 3, 3</strong>。</p>
</li>
<li>
<p><strong>训练增强：</strong></p>
<ul>
<li>Batch Size 增大为 (32, 16)。</li>
<li>迭代次数增加到 25 万次 (250K)。</li>
<li>学习率策略：在 15 万次时降至 1e-5。</li>
</ul>
</li>
</ul>
<h3 id="%E6%80%BB%E7%BB%93-3" tabindex="-1">总结</h3>
<p>这一段展示了严谨的实验设计：</p>
<ol>
<li><strong>CASIA-B</strong> 用来证明模型能不能抗干扰（背包、换衣服）。</li>
<li><strong>OU-MVLP</strong> 用来证明模型能不能“在大场面下”工作（海量人群）。</li>
<li><strong>OU-MVLP 的网络调整</strong> 暗示了 GaitPart 架构具有可扩展性，可以通过加深层数来适应更大的数据规模。</li>
</ol>
<hr>
<h2 id="4.2-%E5%AF%B9%E6%AF%94%E5%AE%9E%E9%AA%8C" tabindex="-1">4.2 对比实验</h2>
<p><strong>GaitPart</strong> 与当时最先进（State-of-the-art, SOTA）的其他步态识别方法进行的对比实验结果。作者通过这两个实验证明了 GaitPart 不仅在准确率上领先，而且在模型效率上也具有显著优势。从 <strong>CASIA-B（综合性能对比）</strong> 和 <strong>OU-MVLP（泛化能力对比）</strong> 两个维度解读。</p>
<h3 id="1.-casia-b-%E4%B8%8A%E7%9A%84%E5%AF%B9%E6%AF%94%E5%AE%9E%E9%AA%8C-(%E7%BB%BC%E5%90%88%E6%80%A7%E8%83%BD)" tabindex="-1">1. CASIA-B 上的对比实验 (综合性能)</h3>
<p>在这一部分，作者对比了三种代表性的方法：<strong>CNN-LB</strong> (基于GEI)、<strong>GaitSet</strong> (基于集合) 和 <strong>GaitNet</strong> (基于LSTM)。</p>
<p>[image]</p>
<h4 id="a.-%E8%A7%86%E9%A2%91%E6%B5%81-vs.-%E9%9D%99%E6%80%81%E5%9B%BE-(video-based-vs.-gei-based)" tabindex="-1"><strong>A. 视频流 vs. 静态图 (Video-based vs. GEI-based)</strong></h4>
<ul>
<li><strong>对比对象：</strong> CNN-LB是一种基于 <strong>GEI (步态能量图)</strong> 的方法，即将视频压缩成一张图来处理。而表格中其他方法都是基于视频序列的。</li>
<li><strong>结果：</strong> 所有基于视频的方法（GaitSet, GaitNet, GaitPart）都显著超越了CNN-LB。</li>
<li><strong>结论：</strong> 这证明了直接处理<strong>原始步态序列 (Raw gait sequence)</strong> 能比单一的能量图提取出更细粒度、更具辨识度的信息。</li>
</ul>
<h4 id="b.-%E6%95%88%E7%8E%87%E4%B8%8E%E6%80%A7%E8%83%BD%E7%9A%84%E5%8F%8C%E8%B5%A2-(vs.-gaitset)" tabindex="-1"><strong>B. 效率与性能的双赢 (vs. GaitSet)</strong></h4>
<ul>
<li><strong>对比对象：</strong> GaitSet 是该领域的标杆模型。</li>
<li><strong>结果：</strong> GaitPart 在拥有类似骨干网络的情况下，性能明显优于 GaitSet。</li>
<li><strong>关键优势：</strong> 作者特别指出，<strong>GaitPart 的参数量仅为 GaitSet 的一半左右</strong>。</li>
<li><strong>结论：</strong> 这通过实验证明了 <strong>FConv (焦点卷积)</strong> 和 <strong>MCM (微动捕捉)</strong> 模块的设计比单纯的集合操作更高效、更精准。</li>
</ul>
<h4 id="c.-%E5%BB%BA%E6%A8%A1%E6%96%B9%E5%BC%8F%E7%9A%84%E8%83%9C%E5%88%A9-(vs.-gaitnet)" tabindex="-1"><strong>C. 建模方式的胜利 (vs. GaitNet)</strong></h4>
<ul>
<li><strong>对比对象：</strong> GaitNet 使用了“自编码器 + 多层 LSTM”的结构。</li>
<li><strong>结果：</strong> GaitPart 在各种行走状态下（尤其是复杂的背包和换衣场景）都取得了更好的表现。</li>
<li><strong>结论：</strong> 这印证了作者之前的假设：针对步态这种周期性运动，GaitPart 的<strong>局部短时建模 (MCM)</strong> 比 LSTM 的<strong>长时序列建模</strong>更有效。</li>
</ul>
<blockquote>
<p>Table 3:特别关注表格最下方的 CL #1-2 (换衣场景)。这是最难的任务。</p>
<ul>
<li>CNN-LB 只有 54.0%，GaitNet 只有 58.9%，GaitSet 提升到 70.4%，<strong>GaitPart 达到了 78.7%</strong>，优势非常明显。</li>
</ul>
</blockquote>
<h3 id="2.-ou-mvlp-%E4%B8%8A%E7%9A%84%E5%AF%B9%E6%AF%94%E5%AE%9E%E9%AA%8C-(%E6%B3%9B%E5%8C%96%E8%83%BD%E5%8A%9B)" tabindex="-1">2. OU-MVLP 上的对比实验 (泛化能力)</h3>
<p>为了验证模型在超大规模数据上的表现，作者使用了包含一万多人的 OU-MVLP 数据集。</p>
<p>[image]</p>
<h4 id="a.-%E5%88%B7%E6%96%B0-sota" tabindex="-1"><strong>A. 刷新 SOTA</strong></h4>
<ul>
<li><strong>结果：</strong> 如 Table 4 所示，GaitPart 在各个视角下的平均Rank-1准确率达到了<strong>88.7%</strong>，超越了 GaitSet (87.1%) 和 GEINet (35.8%)，达到了新的 SOTA 水平。</li>
</ul>
<h4 id="b.-%E5%85%B3%E4%BA%8E-%2288.7%25%22-%E7%9A%84%E9%87%8D%E8%A6%81%E8%AF%B4%E6%98%8E" tabindex="-1"><strong>B. 关于 "88.7%" 的重要说明</strong></h4>
<p>作者特别解释了一个数据上的细节：<strong>现象：</strong> 准确率最高也到不了 100%。<strong>原因：</strong> 这是因为测试集中有一些受试者<strong>缺失了对应的样本</strong>（即有的 Probe 找不到对应的 Gallery），这部分被算作错误。<strong>校正后：</strong> 如果排除掉这些本来就没有数据的无效样本，GaitPart 的实际平均准确率应该高达 <strong>95.1%</strong>。</p>
<h3 id="%E6%80%BB%E7%BB%93-(key-takeaways)" tabindex="-1">总结 (Key Takeaways)</h3>
<p>这段实验分析传递了三个核心信息：</p>
<ol>
<li><strong>更准：</strong> 在困难场景（如换衣 CL）下，GaitPart 的识别率大幅领先。</li>
<li><strong>更轻：</strong> 相比于强大的对手 GaitSet，GaitPart 用一半的参数量做到了更好的效果。</li>
<li><strong>更稳：</strong> 在全球最大的数据集上，GaitPart 依然保持了最先进的性能，证明它不是“过拟合”特定小数据集的模型。</li>
</ol>
<hr>
<h2 id="4.3-%E6%B6%88%E8%9E%8D%E5%AE%9E%E9%AA%8C-ablation-study" tabindex="-1"><strong>4.3 消融实验 Ablation Study</strong></h2>
<p>所谓的消融实验，就是把模型“拆开”来测，通过控制变量法，分别验证模型中每一个组件（FConv 和 MCM）到底有没有用，以及参数该怎么设才最好。所有的实验都是在 <strong>CASIA-B</strong> 数据集上进行的。实验结果分为 <strong>空间维度 (FConv)</strong> 和 <strong>时间维度 (MCM)</strong> 两个部分。</p>
<h3 id="1.-%E9%AA%8C%E8%AF%81-fconv-%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7-(%E7%A9%BA%E9%97%B4%E7%BB%B4%E5%BA%A6)" tabindex="-1">1. 验证 FConv 的有效性 (空间维度)</h3>
<p>这一组实验主要探究：<strong>我们到底应该把图像切成几块 (</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span><strong>值设为多少)？</strong></p>
<p>[image]</p>
<p><strong>Table 5</strong> (Group A)，作者对比了四种不同的设置方案：</p>
<ul>
<li><strong>方案 A-a (1-1-1)：<strong>所有的 Block 中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 。这意味着</strong>完全不使用 FConv</strong>（相当于普通卷积）。</li>
<li>**方案 A-c (1-4-8)：**随着层数加深，逐渐增加切分数量（1 -&gt; 4 -&gt; 8）。这是最终选定的方案。</li>
<li>**方案 A-d (2-4-8)：**在第一层就开始切分 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">p=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> )。</li>
</ul>
<h4 id="%E5%AE%9E%E9%AA%8C%E7%BB%93%E8%AE%BA%EF%BC%9A" tabindex="-1"><strong>实验结论：</strong></h4>
<ol>
<li>
<p><strong>FConv 确实有效：</strong> 只要使用了 FConv 的方案（A-b, c, d），整体效果都比完全不用的 A-a 要好。这证明了限制感受野、关注局部细节的思路是对的。</p>
</li>
<li>
<p><strong>浅层不要切 (Shallow layers need global view)：</strong> 对比 A-c 和 A-d，发现在第一层（Block1）如果使用 FConv (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">p=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> )，效果反而下降了。</p>
<ul>
<li><strong>原因分析：</strong> 浅层网络主要负责提取边缘和轮廓。如果过早切分，会破坏相邻部位之间的边缘连续性信息。</li>
</ul>
</li>
<li>
<p><strong>深层切分对困难场景更有用：</strong> 随着 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 值增大（方案 c vs. b），在 <strong>BG (背包)</strong> 和 <strong>CL (换衣)</strong> 这种复杂场景下的提升非常明显。这意味着局部细节特征对于抗干扰非常关键。</p>
</li>
</ol>
<h3 id="2.-%E9%AA%8C%E8%AF%81-mcm-%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7-(%E6%97%B6%E9%97%B4%E7%BB%B4%E5%BA%A6)" tabindex="-1">2. 验证 MCM 的有效性 (时间维度)</h3>
<p>这一组实验主要探究：<strong>微动捕捉模块 (MCM) 内部的结构该怎么设计？</strong></p>
<p><strong>Table 6</strong> (Group B)，作者对比了 MTB 的组合、注意力机制以及池化方式：</p>
<p>[image]</p>
<pre class="hljs"><code><div>表6.消融研究，B组。控制条件：使用和不使用MTB1或MTB2，使用和不使用MTB中的注意机制以及TP的不同实例。结果是11个视图的平均rank1准确度，不包括相同视图的情况。
</div></code></pre>
<h4 id="a.-%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E4%B8%8E%E5%A4%9A%E5%B0%BA%E5%BA%A6-(mtb1-vs.-mtb2)" tabindex="-1"><strong>A. 窗口大小与多尺度 (MTB1 vs. MTB2)</strong></h4>
<ul>
<li><strong>对比：</strong> B-b (只用 MTB1, 窗口3) vs. B-c (只用 MTB2, 窗口5) vs. <strong>B-a (两者都用)</strong>。</li>
<li><strong>结论：</strong> <strong>双管齐下 (B-a)</strong> 的效果最好。</li>
<li><strong>原因：</strong> 这证明了多尺度设计（Multi-scale）是有效的。同时捕捉“快一点的微动”和“慢一点的微动”，能获得更丰富的特征。</li>
</ul>
<h4 id="b.-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6-(attention)" tabindex="-1"><strong>B. 注意力机制 (Attention)</strong></h4>
<ul>
<li><strong>对比：</strong> B-a (有 Attention) vs. B-d (无 Attention)。</li>
<li><strong>结论：</strong> 去掉注意力机制后，准确率全面下降。</li>
<li><strong>原因：</strong> 证明了引入通道注意力机制确实能帮助模型自动筛选出最具代表性的微动特征。</li>
</ul>
<h4 id="c.-%E6%B1%A0%E5%8C%96%E6%96%B9%E5%BC%8F-(tp%EF%BC%9Amax-vs.-mean)" tabindex="-1"><strong>C. 池化方式 (TP：Max vs. Mean)</strong></h4>
<p>这是一个非常关键的对比，验证了之前的理论假设。</p>
<ul>
<li><strong>对比：</strong> B-a (Max Pooling) vs. B-e (Mean Pooling)。</li>
<li><strong>结果：</strong> 使用 Mean Pooling (B-e) 的效果<strong>最差</strong>，甚至不如不用 FConv 的版本。</li>
<li><strong>原因：</strong> 这验证了 <strong>"Ground Principle"</strong>。步态是周期性的，取最大值 (Max) 能保证特征在周期内的稳定性；而取平均值 (Mean) 会因为视频长度不是周期的整数倍而引入噪声。</li>
</ul>
<h3 id="summary-2" tabindex="-1">Summary</h3>
<p>通过这一系列严谨的消融实验，作者确定了 <strong>GaitPart 的最终形态 (Baseline)</strong>：</p>
<ol>
<li><strong>FPFE 设置：</strong> 采用 <strong>1-4-8</strong> 的渐进式切分策略（浅层不切，深层细切）。</li>
<li><strong>MCM 设置：</strong> 并行使用 <strong>MTB1 和 MTB2</strong>（多尺度），开启<strong>注意力机制</strong>，并使用 <strong>Max Pooling</strong> 进行时序聚合。</li>
</ol>
<p>这也解释了为什么 GaitPart 能在前面的 SOTA 对比中取得那么好的成绩：每一个组件的设计细节都经过了实验数据的反复推敲和验证。</p>
<hr>
<h2 id="4.4-%E6%97%B6%E7%A9%BA%E5%88%86%E6%9E%90-spatio-temporal-study" tabindex="-1"><strong>4.4 时空分析 Spatio-temporal Study</strong></h2>
<p>这个实验非常有意思，作者试图回答一个在步态识别领域争论已久的问题：**到底是我们长的样子（静态外观）重要，还是我们走路的动作（时序动态）重要？**为了搞清楚 GaitPart 到底学到了什么，作者设计了一组“打乱顺序”的对照实验。</p>
<h3 id="1.-%E5%AE%9E%E9%AA%8C%E8%83%8C%E6%99%AF%E4%B8%8E%E7%9B%AE%E7%9A%84" tabindex="-1">1. 实验背景与目的</h3>
<ul>
<li>
<p><strong>背景：</strong> 之前的很多方法（如 GaitSet）认为时间顺序不重要，只要有一堆剪影就能识别。但 GaitPart 引入了 MCM 专门捕捉微动，理论上应该很依赖时间顺序。</p>
</li>
<li>
<p><strong>目的：</strong> 把输入的视频帧<strong>打乱顺序 (Shuffle)</strong>，看看模型的准确率会不会暴跌。</p>
<ul>
<li>如果暴跌 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 说明<strong>时间信息 (Temporal)</strong> 极其重要。</li>
<li>如果没跌多少 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>说明 <strong>外观信息 (Appearance)</strong> 才是主力。</li>
</ul>
</li>
</ul>
<h3 id="2.-%E5%AE%9E%E9%AA%8C%E8%AE%BE%E7%BD%AE-(group-c)" tabindex="-1">2. 实验设置 (Group C)</h3>
<p><strong>Table 7</strong> ，作者设置了三种情况：</p>
<ol>
<li>**C-a (Train Shuffle)：**训练时把帧打乱，测试时正常。</li>
<li>**C-b (Baseline)：**训练和测试都正常（不打乱）。这是标准对照组。</li>
<li>**C-c (Test Shuffle)：**训练时正常，测试时突然把帧打乱。</li>
</ol>
<p>[image]</p>
<pre class="hljs"><code><div>表7.时空研究，C组。控制条件：在训练/测试阶段对输入序列进行排序/打乱。结果是11个视图的平均rank1准确度，不包括相同视图的情况。
</div></code></pre>
<h3 id="3.-%E7%BB%93%E6%9E%9C%E4%B8%8E%E6%B4%9E%E5%AF%9F" tabindex="-1">3. 结果与洞察</h3>
<h4 id="a.-%E9%9D%99%E6%80%81%E5%A4%96%E8%A7%82%E6%98%AF%E2%80%9C%E5%9F%BA%E6%9C%AC%E7%9B%98%E2%80%9D" tabindex="-1"><strong>A. 静态外观是“基本盘”</strong></h4>
<ul>
<li>
<p><strong>现象：</strong> 即使打乱了顺序（C-a 和 C-c），模型的准确率虽然有所下降，但<strong>并没有崩盘</strong>。</p>
<ul>
<li>例如在 NM（正常行走）条件下，C-b 是 96.2%，C-c 即使乱序也有 92.5%。</li>
</ul>
</li>
<li>
<p><strong>结论：</strong> 这说明<strong>静态外观特征 (Static appearance features)</strong> 确实在步态识别中扮演了至关重要的角色。即便没有动作连贯性，光靠身形轮廓也能识别出大部分人。</p>
</li>
</ul>
<h4 id="b.-%E6%97%B6%E9%97%B4%E4%BF%A1%E6%81%AF%E6%98%AF%E2%80%9C%E6%9D%80%E6%89%8B%E9%94%8F%E2%80%9D" tabindex="-1"><strong>B. 时间信息是“杀手锏”</strong></h4>
<ul>
<li>
<p><strong>现象：</strong> 请特别注意 <strong>CL (换衣)</strong> 这一列的数据。</p>
<ul>
<li>正常顺序 (C-b)：**78.7%；**测试乱序 (C-c)：<strong>65.1%</strong></li>
<li><strong>跌幅巨大：</strong> 在换衣场景下，准确率掉了 13% 以上。</li>
</ul>
</li>
<li>
<p><strong>结论：</strong></p>
<ul>
<li>当人穿了大衣（CL），身形轮廓（外观）发生了巨大改变，这时候“看外形”就不准了。</li>
<li>此时，<strong>动作模式（时间信息）</strong> 就成了救命稻草。GaitPart 通过 MCM 捕捉到的微动特征，在外观受干扰时提供了关键的鲁棒性。</li>
</ul>
</li>
</ul>
<h3 id="%E6%80%BB%E7%BB%93-4" tabindex="-1">总结</h3>
<p>这个实验完美地为论文画上了句号：GaitPart 之所以强，是因为它“两条腿走路”：既利用了外观特征保住了基本准确率，又利用 MCM 提取的时间特征解决了换衣、背包等复杂场景下的识别难题。</p>
<hr>
<h1 id="5-%E6%80%BB%E7%BB%93-conclusion" tabindex="-1">5 <strong>总结 Conclusion</strong></h1>
<h2 id="1.-%E6%A0%B8%E5%BF%83%E6%B4%9E%E5%AF%9F-(the-novel-insight)" tabindex="-1">1. 核心洞察 (The Novel Insight)</h2>
<p>作者再次强调了这篇论文的<strong>出发点</strong>：</p>
<ul>
<li><strong>观点：</strong> 人体的不同部位（头、身、腿）在行走时，无论是<strong>视觉外观</strong>还是<strong>运动模式</strong>，都有着本质的区别。</li>
<li><strong>推论：</strong> 因此，不能“一锅端”，<strong>每个部位都需要拥有自己专属的时空建模方式</strong>。</li>
</ul>
<h2 id="2.-%E6%8F%90%E5%87%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-(the-proposed-solution%EF%BC%9Agaitpart)" tabindex="-1">2. 提出的解决方案 (The Proposed Solution：GaitPart)</h2>
<p>基于上述洞察，作者提出了 <strong>GaitPart</strong> 模型，它由两个核心组件构成，分别解决空间和时间问题：</p>
<ul>
<li>
<p><strong>空间上：FPFE (帧级局部特征提取器)</strong></p>
<ul>
<li><strong>核心技术：</strong> <strong>FConv (焦点卷积)</strong>。</li>
<li><strong>目的：</strong> 增强<strong>局部特征的细粒度学习</strong> (enhance the fine-grained learning of part-level features)。也就是让模型能更精细地看清每个部位的细节。</li>
</ul>
</li>
<li>
<p><strong>时间上：TFA (时序特征聚合器)</strong></p>
<ul>
<li><strong>核心技术：</strong> 若干个并行且参数独立 (dependent) 的 <strong>MCM (微动捕捉模块)</strong>。</li>
<li><strong>目的：</strong> 提取<strong>局部的、短距离的时空表达</strong> (extract the local short-range spatio-temporal expressions)。也就是不再关注冗长的整个周期，而是专注于捕捉瞬间的微小动作。</li>
</ul>
</li>
</ul>
<blockquote>
<p><em>注：这里的 "dependent" 呼应了前文提到的 "Part-dependent"，意思是指这些模块是</em>“因部位而异”<em>的，即头部有头部的参数，腿部有腿部的参数，互不混用。</em></p>
</blockquote>
<h2 id="3.-%E6%9C%80%E7%BB%88%E6%88%90%E5%B0%B1-(final-achievement)" tabindex="-1">3. 最终成就 (Final Achievement)</h2>
<ul>
<li><strong>验证：</strong> 在两个最权威的公共数据集 <strong>CASIA-B</strong> 和 <strong>OU-MVLP</strong> 上进行了实验。</li>
<li><strong>结论：</strong> 实验结果充分证明了 <strong>GaitPart 整体模型</strong> 以及其 <strong>所有组件</strong> (FConv, MCM) 的优越性。</li>
</ul>
<p><strong>核心回顾：</strong></p>
<ol>
<li>
<p><strong>痛点：</strong> 传统方法忽略了人体部位差异和局部微动。</p>
</li>
<li>
<p><strong>方法：</strong> 提出了 <strong>GaitPart</strong>。</p>
<ul>
<li>空间上：用 <strong>FConv</strong> 切分人体，细看局部。</li>
<li>时间上：用 <strong>MCM</strong> 捕捉短时微动。</li>
</ul>
</li>
<li>
<p><strong>结果：</strong> 在 CASIA-B 和 OU-MVLP 上取得了 SOTA，特别是换衣场景提升巨大。</p>
</li>
</ol>
<ul>
<li>
<p><strong>它的核心贡献</strong>在于打破了以往将人体视为整体进行长序列分析的惯性思维。</p>
</li>
<li>
<p><strong>它的成功秘诀</strong>在于“<strong>分块 (Part-based)</strong>”和“<strong>微动 (Micro-motion)</strong>”：</p>
<ol>
<li>用 <strong>FConv</strong> 像手术刀一样把人体切开，精细化处理空间特征。</li>
<li>用 <strong>MCM</strong> 像放大镜一样聚焦时间轴，捕捉最具辨识度的短时微动。</li>
</ol>
</li>
</ul>
<p>这种设计使得模型在处理<strong>换衣、背包</strong>等复杂场景时表现出了惊人的鲁棒性，同时保持了较低的参数量和极高的准确率。</p>
<hr>
<hr>
<h1 id="%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90" tabindex="-1">代码解析</h1>
<p>这段的核心思想：**将特征图在空间上水平切分（Horizontal Pooling），然后对每个切分后的部位（Part）独立进行时间维度的微动捕捉（MCM/TFA）。**以下是核心概念与论文的对应关系：</p>
<h2 id="a.-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%EF%BC%9Atemporalfeatureaggregator-(tfa)3.3-%E6%97%B6%E5%BA%8F%E7%89%B9%E5%BE%81%E8%81%9A%E5%90%88%E5%99%A8tfa---gaitpart" tabindex="-1">A. 核心模块：<code>TemporalFeatureAggregator</code> (TFA)<a href="zotero://note/u/JSDKKYSD/?section=3.3%20%E6%97%B6%E5%BA%8F%E7%89%B9%E5%BE%81%E8%81%9A%E5%90%88%E5%99%A8TFA">3.3 时序特征聚合器TFA - GaitPart</a></h2>
<p>这是论文中 <strong>MCM (Micro-motion Capture Module)</strong> 的具体实现。</p>
<ol>
<li>
<p><strong>Part-Dependent (部位独立性)</strong>：</p>
<ul>
<li><strong>代码体现</strong>：<code>self.conv1d3x1 = clones(conv3x1, parts_num)</code>。</li>
<li><strong>原理</strong>：使用 <code>clones</code> 函数复制了16个（设parts_num=16）结构相同但权重不共享的小网络。</li>
<li><strong>目的</strong>：头部、躯干、腿部的运动模式不同，独立的参数能让模型分别学习各部位特有的微动模式。</li>
</ul>
</li>
<li>
<p><strong>Short-range Spatio-temporal Features (短时特征)</strong>：</p>
<ul>
<li><strong>代码体现</strong>：<code>BasicConv1d(..., kernel_size=3)</code> 和 <code>AvgPool1d(3)</code>。</li>
<li><strong>原理</strong>：相比于 LSTM 或 全局 3D-CNN，这里只在很小的时间窗口（3帧或5帧）内进行卷积和池化。</li>
<li><strong>目的</strong>：捕捉行走时的瞬间动作变化（微动）。</li>
</ul>
</li>
<li>
<p><strong>Attention Mechanism (注意力机制)</strong>：</p>
<ul>
<li><strong>代码体现</strong>：<code>scores3x1 = torch.sigmoid(logits3x1)</code> 然后 <code>feature * scores</code>。</li>
<li><strong>原理</strong>：使用 1D 卷积计算出一个 0~1 之间的权重 mask，乘在特征上。</li>
<li><strong>目的</strong>：增强关键的微动特征，抑制噪声。</li>
</ul>
</li>
<li>
<p><strong>MTB1 &amp; MTB2 (多尺度设计)</strong>：</p>
<ul>
<li><strong>代码体现</strong>：分别定义了 kernel=3 和 kernel=5 (padding=2) 的两组操作，最后相加 <code>feature3x1 + feature3x3</code>。</li>
<li><strong>目的</strong>：融合不同时间跨度的特征，提高鲁棒性。</li>
</ul>
</li>
</ol>
<h2 id="b.-%E6%95%B0%E6%8D%AE%E6%B5%81-(data-flow)-3.1-pipeline---gaitpart" tabindex="-1">B. 数据流 (Data Flow) <a href="zotero://note/u/JSDKKYSD/?section=3.1%20Pipeline">3.1 Pipeline - GaitPart</a></h2>
<ol>
<li><strong>Backbone</strong>：<code>[n, c, s, h, w]</code> -&gt; 每一帧单独提取图像特征。</li>
<li><strong>HPP (Horizontal Pooling)</strong>：<code>[n, c, s, h, w] -&gt; [n, c, s, p]</code> -&gt; 每一帧被水平切成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 个条带，降维成向量。</li>
<li><strong>TFA (MCM)</strong>：<code>[n, c, s, p] -&gt; [n, c, p]</code> -&gt; 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> (时间) 维度上进行微动提取和Max Pooling，时间维度消失。</li>
<li><strong>Head (SeparateFCs)</strong>：<code>[n, c, p] -&gt; [n, c_out, p]</code> -&gt; 将特征映射到用于计算 Triplet Loss 的特征空间。</li>
</ol>
<h2 id="c.-%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%AF%B4%E6%98%8E" tabindex="-1">C. 工具类说明</h2>
<ul>
<li><code>SetBlockWrapper</code>：OpenGait 的工具，用于把 5D 数据 <code>[n, c, s, h, w]</code> 里的 <code>n</code> 和 <code>s</code> 合并成 <code>n*s</code>，喂给只接受 4D 输入的普通 CNN (ResNet 等)，处理完后再变回 5D。</li>
<li><code>HorizontalPoolingPyramid</code>：对应论文中的“水平切分”，通常包含 Global Max Pooling + Global Avg Pooling。</li>
<li><code>SeparateFCs</code>：对应论文最后的 "Separate FC layers"，也是 Part-dependent 的，每个部位特征有自己专属的全连接层。</li>
</ul>
<hr>
<h2 id="1.-micro-motion-capture-module-(mcm)%EF%BC%9A%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%90%E5%8F%96%E7%9F%AD%E6%97%B6%E5%BA%8F%E4%BF%A1%E6%81%AF%E7%9A%84%EF%BC%9F%E8%BF%99%E4%B8%8E-gaitset-%E7%9A%84%E7%B2%97%E6%9A%B4%E6%B1%A0%E5%8C%96%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F" tabindex="-1">1. Micro-motion Capture Module (MCM)：是如何提取短时序信息的？这与 GaitSet 的粗暴池化有何不同？</h2>
<p>MCM 的设计初衷是捕捉“微动”（Micro-motion），即短时间内的动作变化，而非长时间的统计信息。</p>
<h3 id="mcm-%E7%9A%84%E6%8F%90%E5%8F%96%E6%9C%BA%E5%88%B6" tabindex="-1"><strong>MCM 的提取机制</strong></h3>
<p>从提供的代码 <code>TemporalFeatureAggregator</code> 类可以看出其工作流程：</p>
<ol>
<li><strong>滑动窗口 (Sliding Window)</strong>：使用 <code>kernel_size=3</code> 或 <code>5</code> 的 1D 卷积/池化在时间轴 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 上滑动。这对应了论文中提到的提取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 帧及其邻域帧 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>r</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i-r, ..., i+r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span> 的信息。</li>
<li><strong>微动模版 (Template Function)</strong>：<code>self.avg_pool3x1(x) + self.max_pool3x1(x)</code>。它在小窗口内结合了平均值和最大值，捕捉局部的动态变化。</li>
<li><strong>注意力重加权 (Attention Re-weighting)</strong>： <code>scores3x1 = torch.sigmoid(logits3x1)</code>。它通过一个小型的卷积网络计算出权重，强调那些最具辨识度的微动瞬间，抑制静止或噪声帧。</li>
</ol>
<h3 id="%E4%B8%8E-gaitset-%E7%9A%84%E5%8C%BA%E5%88%AB" tabindex="-1"><strong>与 GaitSet 的区别</strong></h3>
<ul>
<li>
<p><strong>GaitSet (粗暴池化 / Set-based)</strong>：</p>
<ul>
<li><strong>机制</strong>：将步态序列视为无序的<strong>集合 (Set)</strong>。它直接对<strong>整个视频序列</strong>进行全局最大池化 (Global Max Pooling)，把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 帧直接压缩成 1 帧。</li>
<li><strong>缺陷</strong>：虽然简洁，但它<strong>完全丢失了时间顺序</strong>和帧与帧之间的精细动态变化（即丢失了“迈步过程”中的微动信息）。</li>
</ul>
</li>
<li>
<p><strong>GaitPart (MCM)</strong>：</p>
<ul>
<li><strong>优势</strong>：MCM 关注的是<strong>局部短时依赖 (Local short-range dependencies)</strong>。它不把整个视频压扁，而是看“这一帧和前后两帧”的关系，从而保留了动作发生的动态细节。</li>
</ul>
</li>
</ul>
<h2 id="2.-%E5%A6%82%E4%BD%95%E5%B0%86%E7%89%B9%E5%BE%81%E5%9B%BE%E5%9C%A8%E9%AB%98%E5%BA%A6%EF%BC%88height%EF%BC%89%E6%96%B9%E5%90%91%E5%88%87%E5%88%86%E4%B8%BA%E5%A4%9A%E4%B8%AA-parts-%E7%9A%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88-opengait-%E4%B8%AD%E5%BE%88%E5%A4%9A%E6%A8%A1%E5%9E%8B%E4%BC%9A%E6%9C%89-p-(parts)-%E8%BF%99%E4%B8%AA%E7%BB%B4%E5%BA%A6%EF%BC%9F" tabindex="-1">2. 如何将特征图在高度（Height）方向切分为多个 Parts 的？为什么 OpenGait 中很多模型会有 p (parts) 这个维度？</h2>
<h3 id="%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%88%87%E5%88%86%E5%AE%9E%E7%8E%B0" tabindex="-1"><strong>代码中的切分实现</strong></h3>
<p>在 <code>GaitPart</code> 类的 <code>forward</code> 函数中，切分操作是由 <code>HorizontalPoolingPyramid</code> (HPP) 模块完成的：</p>
<pre class="hljs"><code><div># 此时out的维度是[n, c, s, h, w](Batch, Channel, Time, Height, Width)
out = self.Backbone(sils)
# 关键步骤：HPP模块将(h, w)空间维度转换为p(parts)维度
# 输出out的维度变为[n, c, s, p]
out = self.HPP(out)
</div></code></pre>
<p>虽然代码没有给出 <code>HorizontalPoolingPyramid</code> 的内部实现逻辑是：</p>
<ol>
<li><strong>水平切片</strong>：将高度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span> 平均切分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 份。</li>
<li><strong>池化降维</strong>：对每一份（Part）进行 Global Max + Avg Pooling，将该部分的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow></msub><mo>×</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">H_{part} \times W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span> 压缩为一个数值。</li>
<li><strong>结果</strong>：原来的图像空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>H</mi><mo separator="true">,</mo><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(H, W)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose">)</span></span></span></span> 就变成了一个向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>，代表人体从头到脚的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 个水平条带的特征。</li>
</ol>
<h3 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-p-(parts)-%E8%BF%99%E4%B8%AA%E7%BB%B4%E5%BA%A6%EF%BC%9F" tabindex="-1"><strong>为什么要有</strong> <code>p</code> (parts) 这个维度？</h3>
<p>这源于步态识别的一个核心假设：<strong>Part-based Assumption (分块假设)</strong>。</p>
<ol>
<li>
<p><strong>部位差异性</strong>：论文反复强调，人体不同部位（头、躯干、腿）在行走时的<strong>运动模式</strong>和<strong>视觉外观</strong>截然不同。例如，头是相对静止的，手是摆动的，腿是交替跨越的。</p>
</li>
<li>
<p><strong>独立建模 (Part-dependent)</strong>：引入 <code>p</code> 维度后，模型可以针对每个部位使用<strong>独立不共享的参数</strong>。</p>
<ul>
<li>代码证明：在 <code>TemporalFeatureAggregator</code> 中，使用了 <code>clones(conv3x1, parts_num)</code>。这意味着如果有 16 个 part，就有 16 个独立的卷积网络，第 1 个网络专门学“头怎么动”，第 16 个网络专门学“脚怎么动”，互不干扰。</li>
</ul>
</li>
</ol>
<p>总结来说，<code>p</code> 维度是步态识别中为了实现<strong>精细化局部建模</strong>而特有的维度设计。</p>

    </div>


</body></html>